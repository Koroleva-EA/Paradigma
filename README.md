# Объектно-ориентированное программирование
Наиболее распространённая на данный момент парадигма. Это подвид императивного программирования — оно основано на последовательных вызовах команд, изменяющих данные, с которыми работает программа. Таким образом, она оперирует объектами, и это удобно для многих приложений.
Новичков зачастую пугает аббревиатура ООП, но освоить парадигму объектно-ориентированного программирования не так сложно, как кажется. В своё время эта идея оказалась вирусной: создавать объекты, принадлежащие классам, а также использовать методы в качестве действий, которые может выполнить объект или которые можно произвести над ним. Много специалистов по Computer Science придерживаются такого подхода. Большое преимущество здесь в том, что программисту, использующему ООП, легко разобраться, что происходит в программе. Достаточно посмотреть, какие действия производит каждый из объектов.
Легче всего использовать ООП в Python, посложнее — в C++. Но если в этих языках у программиста ещё есть возможность увильнуть от ООП (например, для Python вполне подходит функциональное программирование), то в Java и C# всегда необходимо создавать классы, одних функций недостаточно.
##Недостатки ООП
Документирование классов - задача более трудная, чем это было в случае процедур и модулей. Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но также и о том, в каком контексте он вызывается. Ведь переопределенные методы обычно вызываются не клиентом, а самим каркасом. Таким образом, программист должен знать, какие условия выполняются, когда вызывается данный метод. Для абстрактных методов, которые пусты, в документации должно даже говориться о том, для каких целей предполагается использовать переопределяемый метод.
В сложных иерархиях классов поля и методы обычно наследуются с разных уровней. И не всегда легко определить, какие поля и методы фактически относятся к данному классу.
Для получения такой информации нужны специальные инструменты вроде навигаторов классов. Если конкретный класс расширяется, то каждый метод обычно сокращают перед передачей сообщения базовому классу. Реализация операции, таким образом, рассредоточивается по нескольким классам, и чтобы понять, как она работает, нам приходится внимательно просматривать весь код.
Методы, как правило, короче процедур, поскольку они осуществляют только одну операцию над данными. Зато количество методов намного выше. Короткие методы обладают тем преимуществом, что в них легче разбираться, неудобство же их связано с тем, что код для обработки сообщения иногда "размазан" по многим маленьким методам.
Абстракцией данных не следует злоупотреблять. Чем больше данных скрыто в недрах класса, тем сложнее его расширять. Отправной точкой здесь должно быть не то, что клиентам не разрешается знать о тех или иных данных, а то, что клиентам для работы с классом этих данных знать не требуется.
##Функциональное программирование
По распространённости функциональная парадигма программирования занимает второе место после ООП. Это развитие идей декларативного программирования: программа создаётся как инструмент, который решает определённую задачу и в итоге даёт нужный результат. 
Между последователями разных парадигм, оказавшимися в одной ветке комментариев, всегда разгорается бесконечный холивар с обвинениями в «ООП/ФП головного мозга». Но бывают и программисты, готовые применить любой из подходов в зависимости от проекта.
Наиболее характерный для функционального программирования язык — Haskell. В реальных проектах он применяется редко, но будто создан для красивых решений в духе ФП — поэтому Haskell стал культовым среди профессиональных программистов, предпочитающих эту парадигму.
В ФП код программы состоит из функций, для которых подробно прописано, что должно быть на входе, а что — на выходе. Причём одну функцию вполне можно подать на вход другой в качестве аргумента. Так программа выполняется, запуская нужные функции.
Преимущества функционального подхода — в том, что код легко читать, а тестирование упрощается. Всё потому, что действия, производимые функцией, не зависят от внешнего состояния. Выполнение кода становится более предсказуемым, а неожиданные побочные эффекты — менее вероятными.
Помимо объектно-ориентированного и функционального программирования, есть и другие парадигмы. Некоторые из них уже вытеснены более современными подходами. Но есть и специфические парадигмы, которые нужны для конкретных ситуаций. Расскажем про несколько самых распространённых.
##Недостатки функциональной парадигмы
1. На чистых функциональных языках не существует эффективного неупорядоченного словаря и множества
2. Не существует чисто функциональных слабых хэш-таблиц (weak hash table)
3. Не существует чисто функциональных потокобезопасных коллекций
4. Большинство алгоритмов на графах выглядят хуже и работают намного медленнее, если написаны в функциональном стиле
5. Инерция традиционных императивных структур данных и алгоритмов огромна
6. Как оказывается, все существующие реализации функциональных языков—как чистых, так и нечистых (impure)—спроектированы так, что аллоцируют слишком много памяти
7. Чистое функциональное программирование хорошо для параллелизма в теории, но не очень хорошо с точки зрения производительности на практике, а высокая производительность на практике—единственная настоящая задача параллелизма
8. Понадобилось 50 лет, чтоб разбавить концентрацию высокомерных снобов в сообществе до той степени, чтоб можно было получить полезный ответ по функциональному программированию
9. О функциональном программировании циркулирует множество ложной информации

